module Party where

import Data.Tree (Tree, foldTree)
import Employee

-- Ex. 1
-- 1.
glCons :: Employee -> GuestList -> GuestList
glCons e (GL l fun) = GL (e : l) (fun + empFun e)

-- 2.
instance Semigroup GuestList where
  -- NOTE: try not to get a correct `fun` first
  -- NOTE: yes, this is exactly what we should do
  (GL es1 f1) <> (GL es2 f2) = GL (es1 ++ es2) (f1 + f2)

instance Monoid GuestList where
  mempty = GL [] 0

formatGl :: GuestList -> String
formatGl (GL l fun) = total ++ "\n" ++ others
  where
    total = "Total fun: " ++ show fun
    others = unlines $ map (show . empName) l

-- 3.
moreFun :: GuestList -> GuestList -> GuestList
moreFun = max

-- Ex. 2
-- NOTE: we use Data.Tree.foldTree now
-- treeFold :: (a -> [b] -> b) -> Tree a -> b
-- treeFold f (Node res children) = f res (map (treeFold f) children)

-- Ex.3
nextLevel :: Employee -> [(GuestList, GuestList)] -> (GuestList, GuestList)
nextLevel e l = (gl_boss, gl_no_boss)
  where
    gl_no_boss = mconcat $ map (uncurry moreFun) l
    gl_boss = glCons e $ mconcat $ map snd l

-- Ex.4
maxFun :: Tree Employee -> GuestList
maxFun tree =
  let (gl_boss, gl_no_boss) = foldTree nextLevel tree
   in moreFun gl_boss gl_no_boss

{-
   NOTE: Unlike 'foldr' on lists, 'treeFold' doesn't need an explicit
   initial accumulator (base case). Because a Rose Tree is never empty,
   the recursion "bottoms out" at the leaf nodes, where the
   sub-results list is empty ([]).
   The base value is effectively generated by: f leaf_node_data []
-}

-- Ex. 5
main :: IO ()
main = getContents >>= (putStrLn . formatGl . maxFun . read)
